%prefixes%

	terminal = tok_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	frame  -> frame;
	type   -> type;
	code   -> code;

%header% @{

	#include <assert.h>
	#include <limits.h>
	#include <string.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <errno.h>

	#include <unistd.h>

	#include "debug.h"
	#include "lex.h"
	#include "code.h"
	#include "frame.h"
	#include "parser.h"

	struct act_string {
		const char *s;
		const char *e;
	};

	struct act_state {
		struct lex_tok t;
		enum lex_type type, save;
		struct frame *frame;
		int (*dispatch)(FILE *, struct frame *, char *args[], const struct code *);
		char **args;
	};

	typedef struct act_string string;
	typedef enum code_type type;
	typedef struct code *code;

	#define CURRENT_TERMINAL act_state->type
	#define ERROR_TERMINAL   tok_error
	#define ADVANCE_LEXER    lex_next(lex_state, &act_state->t); \
							 act_state->type = act_state->t.type;
	#define SAVE_LEXER(tok)  act_state->save = tok;
	#define RESTORE_LEXER    act_state->type = act_state->save;

@}, @{

	#include <stdio.h>

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;

	int
	parse(struct lex_state *l,
		int (*dispatch)(FILE *, struct frame *, char *args[], const struct code *),
		char *args[]);

@};

%terminals%

	word: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "str: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

	var: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "var: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

%actions%

	<dispatch>: (c :code &) -> () = @{
		assert(act_state->frame != NULL);
		assert(act_state->args != NULL);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<dispatch>: ");
			code_dump(stderr, @c);
		}

		if (-1 == act_state->dispatch(stdout, act_state->frame, act_state->args, @c)) {
			code_free(@c);
			@!;
		}
	@};

	<var-top>:  () -> (s :string) = @{
		@s.s = "_";
		@s.e = @s.s + 1;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<var-top>: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

	<empty-code>: () -> (c :code) = @{
		@c = NULL;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<empty-code>\n");
		}
	@};

	<stdin>:  () -> (s :string) = @{ @s.s = "0"; @s.e = @s.s + 1; @};
	<stdout>: () -> (s :string) = @{ @s.s = "1"; @s.e = @s.s + 1; @};
	<stderr>: () -> (s :string) = @{ @s.s = "2"; @s.e = @s.s + 1; @};

	<type-call>: () -> (t :type) = @{ @t = CODE_CALL; @};
	<type-join>: () -> (t :type) = @{ @t = CODE_JOIN; @};
	<type-not>:  () -> (t :type) = @{ @t = CODE_NOT;  @};
	<type-null>: () -> (t :type) = @{ @t = CODE_NULL; @};
	<type-ret>:  () -> (t :type) = @{ @t = CODE_RET;  @};
	<type-run>:  () -> (t :type) = @{ @t = CODE_RUN;  @};
	<type-tick>: () -> (t :type) = @{ @t = CODE_TICK; @};

	<type-data>: () -> (t :type) = @{ @t = CODE_DATA; @};
	<type-dup>:  () -> (t :type) = @{ @t = CODE_DUP;  @};
	<type-if>:   () -> (t :type) = @{ @t = CODE_IF;   @};
	<type-pipe>: () -> (t :type) = @{ @t = CODE_PIPE; @};
	<type-set>:  () -> (t :type) = @{ @t = CODE_SET;  @};

	<prepend-anon>: (c :code &, t :type, ci :code) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<prepend-anon>\n");
		}

		if (!code_anon(@&c, act_state->frame, @t, @ci)) {
			@!;
		}
	@};

	<prepend-data>: (c :code &, s :string) -> () = @{
		assert(@s.s != NULL && @s.e != NULL);
		assert(@s.e >= @s.s);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<prepend-data>: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}

		if (!code_data(@&c, act_state->frame, @s.e - @s.s, @s.s)) {
			@!;
		}
	@};

	<prepend-code>: (c :code &, t :type) -> () = @{
		assert(act_state->frame != NULL);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<prepend-code>: %s\n", code_name(@t));
		}

		if (!code_push(@&c, act_state->frame, @t)) {
			@!;
		}
	@};

	<prepend-cat>: (c :code &, ci :code) -> () = @{
		struct code **tail;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<prepend-cat>\n");
		}

		for (tail = @&ci; *tail != NULL; tail = &(*tail)->next)
			;

		*tail = @c;
		@=c = @ci;
	@};

	<append-anon>: (c :code &, t :type, ci :code) -> () = @{
		struct code **tail;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<append-anon>\n");
		}

		for (tail = @&c; *tail != NULL; tail = &(*tail)->next)
			;

		if (!code_anon(tail, act_state->frame, @t, @ci)) {
			@!;
		}
	@};

	<append-data>: (c :code &, s :string) -> () = @{
		struct code **tail;

		assert(@s.s != NULL && @s.e != NULL);
		assert(@s.e >= @s.s);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<append-data>: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}

		for (tail = @&c; *tail != NULL; tail = &(*tail)->next)
			;

		if (!code_data(tail, act_state->frame, @s.e - @s.s, @s.s)) {
			@!;
		}
	@};

	<append-code>: (c :code &, t :type) -> () = @{
		struct code **tail;

		assert(act_state->frame != NULL);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<append-code>: %s\n", code_name(@t));
		}

		for (tail = @&c; *tail != NULL; tail = &(*tail)->next)
			;

		if (!code_push(tail, act_state->frame, @t)) {
			@!;
		}
	@};

	<append-cat>: (c :code &, ci :code) -> () = @{
		struct code **tail;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<append-cat>\n");
		}

		for (tail = @&c; *tail != NULL; tail = &(*tail)->next)
			;

		*tail = @ci;
	@};

	<frame-push>: () -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<frame-push>\n");
		}

		if (!frame_push(&act_state->frame)) {
			@!;
		}
	@};

	<frame-pop>: () -> () = @{
		assert(act_state->frame != NULL);

		/* TODO: could set $. inside here (yes, in <frame-pop>), iff &c is non-NULL.
		 * if &c is NULL, either we're at the top scope, or there's no locally-scoped
		 * code to dereference it anyway */

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<frame-pop>\n");
		}

		(void) frame_pop(&act_state->frame);
	@};

	<frame-set>: (s :string, c :code) -> () = @{
		assert(act_state->frame != NULL);
		assert(@s.s != NULL && @s.e != NULL);
		assert(@s.e > @s.s);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<frame-set>: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}

		if (!frame_set(act_state->frame, @s.e - @s.s, @s.s, @c)) {
			@!;
		}
	@};

	<err-expected-sep>: () -> () = @{
		fprintf(stderr, "syntax error: expected { '\\n' | ';' | '&' }\n");
		@!;
	@};

	<err-syntax>: (c :code) -> () = @{
		fprintf(stderr, "syntax error\n");
		/* TODO:
		fprintf(stderr, "syntax error at: ");
		code_dump(stderr, @c);
		*/
		@!;
	@};

%trailer% @{

	int
	parse(struct lex_state *lex_state,
		int (*dispatch)(FILE *, struct frame *, char *args[], const struct code *),
		char *args[])
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);
		assert(dispatch != NULL);
		assert(args != NULL);

		act_state->dispatch = dispatch;

		act_state->args  = args;
		act_state->frame = NULL;

		lex_state->p = lex_state->buf;

		ADVANCE_LEXER;  /* XXX: what if the first token is unrecognised? */

		/* TODO: handle raising an error or ## */
		p_script(lex_state, act_state);

		return 0;
	}

@}, @{

@};

