%prefixes%

	terminal = tok_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	type   -> type;
	code   -> code;
	mark   -> mark;
	rule   -> rule;
	term   -> term;

%header% @{

	#include <assert.h>
	#include <limits.h>
	#include <string.h>
	#include <stdarg.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <ctype.h>
	#include <errno.h>

	#include <unistd.h>

	#include "debug.h"
	#include "lex.h"
	#include "code.h"
	#include "parser.h"

	enum err_state {
		ERR_NONE,
		ERR_SYNTAX,
		ERR_ERRNO
	};

	struct act_string {
		const char *s;
		const char *e;
	};

	struct act_mark {
		lex_buf buf; /* XXX: large; i don't like passing this around in automatic storage */
		struct pos pos;
	};

	struct act_state {
		struct lex_tok t;
		enum lex_type save;
		struct act_mark mark;
		enum err_state e;
		int (*dispatch)(struct code *);
	};

	typedef struct act_string string;
	typedef enum code_type type;
	typedef struct code *code;
	typedef struct act_mark mark;
	typedef const char * rule;
	typedef enum lex_type term;

	#define CURRENT_TERMINAL act_state->t.type
	#define ERROR_TERMINAL   tok_error
	#define ADVANCE_LEXER    lex_next(lex_state, &act_state->t);
	#define SAVE_LEXER(type) act_state->save   = type;
	#define RESTORE_LEXER    act_state->t.type = act_state->save;

	static void
	err_syntax(const char *buf, const struct pos *pos,
		const char *fmt, ...)
	{
		assert(buf != NULL);
		assert(pos != NULL);

		fprintf(stderr, "syntax error: ");

		if (fmt != NULL) {
			va_list ap;

			va_start(ap, fmt);
			vfprintf(stderr, fmt, ap);
			va_end(ap);
		}

		fprintf(stderr, "\n");

		/*
		 * The lexer's buffer is a line at a time. Here we assume that the
		 * start of the buffer is always the start of a line, and so pos.col
		 * gives the start of the unexpected token.
		 *
		 * For a block-at-a-time lexer, I would prefix "..." if the buffer
		 * were not at the start of a line.
		 */

		/* TODO: conditionally on DEBUG_SRC (default to true) and buf != NULL */
		/* TODO: also position conditionally on pos != NULL */
		{
			size_t i;
			int r;

			r = fprintf(stderr, "at %lu:%lu: ", pos->line, pos->col);
			if (r < 0) {
				perror("fprintf");
				return;
			}

			fprintf(stderr, "%.*s\n", (int) strcspn(buf, "\n"), buf);

			for (i = 0; (int) i < r; i++) {
				fprintf(stderr, "-");
			}

			for (i = 1; i < pos->col; i++) {
				fprintf(stderr, "-");
			}

			fprintf(stderr, "^\n");
		}
	}

@}, @{

	#include <stdio.h>

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;

	int
	parse(struct lex_state *l,
		int (*dispatch)(struct code *));

@};

%terminals%

	word: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "str: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

	var: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "var: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

	obrace: () -> (t :term, m :mark) = @{
		strcpy(@m.buf, lex_state->buf);
		@m.pos = act_state->t.pos;
		@t     = act_state->t.type;
	@};

	oparen: () -> (t :term, m :mark) = @{
		strcpy(@m.buf, lex_state->buf);
		@m.pos = act_state->t.pos;
		@t     = act_state->t.type;
	@};

	osquare: () -> (t :term, m :mark) = @{
		strcpy(@m.buf, lex_state->buf);
		@m.pos = act_state->t.pos;
		@t     = act_state->t.type;
	@};

%actions%

	<dispatch>: (c :code &) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<dispatch>: ");
			code_dump(stderr, @c);
		}

		if (-1 == act_state->dispatch(@c)) {
			@!;
		}
	@};

	<empty-code>: () -> (c :code) = @{
		@c = NULL;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<empty-code>\n");
		}
	@};

	<stdin>:  () -> (s :string) = @{ @s.s = "0"; @s.e = @s.s + 1; @};
	<stdout>: () -> (s :string) = @{ @s.s = "1"; @s.e = @s.s + 1; @};
	<stderr>: () -> (s :string) = @{ @s.s = "2"; @s.e = @s.s + 1; @};

	<type-call>: () -> (t :type) = @{ @t = CODE_CALL; @};
	<type-join>: () -> (t :type) = @{ @t = CODE_JOIN; @};
	<type-not>:  () -> (t :type) = @{ @t = CODE_NOT;  @};
	<type-null>: () -> (t :type) = @{ @t = CODE_NULL; @};
	<type-run>:  () -> (t :type) = @{ @t = CODE_RUN;  @};
	<type-tick>: () -> (t :type) = @{ @t = CODE_TICK; @};
	<type-push>: () -> (t :type) = @{ @t = CODE_PUSH; @};
	<type-pop>:  () -> (t :type) = @{ @t = CODE_POP;  @};
	<type-clhs>: () -> (t :type) = @{ @t = CODE_CLHS; @};
	<type-crhs>: () -> (t :type) = @{ @t = CODE_CRHS; @};
	<type-ctck>: () -> (t :type) = @{ @t = CODE_CTCK; @};

	<type-data>: () -> (t :type) = @{ @t = CODE_DATA; @};
	<type-dup>:  () -> (t :type) = @{ @t = CODE_DUP;  @};
	<type-asc>:  () -> (t :type) = @{ @t = CODE_ASC;  @};
	<type-if>:   () -> (t :type) = @{ @t = CODE_IF;   @};
	<type-pipe>: () -> (t :type) = @{ @t = CODE_PIPE; @};
	<type-set>:  () -> (t :type) = @{ @t = CODE_SET;  @};

	<code-anon>: (c :code &, t :type, ci :code) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-anon>\n");
		}

		/* XXX: leak */
		if (!code_anon(@&c, &lex_state->pos, @t, @ci)) {
			@!;
		}
	@};

	<code-data>: (c :code &, s :string) -> () = @{
		assert(@s.s != NULL && @s.e != NULL);
		assert(@s.e >= @s.s);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-data>: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}

		if (!code_data(@&c, &lex_state->pos, @s.e - @s.s, @s.s)) {
			@!;
		}
	@};

	<code-push>: (c :code &, t :type) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-push>: %s\n", code_name(@t));
		}

		if (!code_push(@&c, &lex_state->pos, @t)) {
			@!;
		}
	@};

	<code-wind>: (c :code &, ci :code) -> () = @{
		struct code **tail;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-wind>\n");
		}

		for (tail = @&ci; *tail != NULL; tail = &(*tail)->next)
			;

		*tail = @c;
		@=c = @ci;
	@};

	<expected-sep>:   () -> (r :rule) = @{ @r = "'\\n' | ';' | '&'"; @};
	<expected-pair>:  () -> (r :rule) = @{ @r = "m '=' n | m '=' | m | x '|' y"; @};
	<expected-value>: () -> (r :rule) = @{ @r = "$var | word | `word | `{ ... } | { ... } | ( ... )"; @};

	<err-expected>: (r :rule) -> () = @{
		assert(@r != NULL);

		if (act_state->e == ERR_NONE) {
			err_syntax(lex_state->buf, &act_state->t.pos, "expected %s", @r);
			act_state->e = ERR_SYNTAX;
		}
	@};

	<err-unmatched>: (t :term, m :mark &) -> () = @{
		assert((isprint)(@t));

		if (act_state->e == ERR_NONE) {
			err_syntax(@&m->buf, &@&m->pos, "unmatched '%c'", (unsigned char) @t);
			act_state->e = ERR_SYNTAX;
		}
	@};

	<err-syntax> = @{
		if (act_state->e == ERR_NONE) {
			err_syntax(lex_state->buf, &act_state->t.pos, NULL);
			act_state->e = ERR_SYNTAX;
		}

		if (act_state->e == ERR_ERRNO) {
			@!;
		}
	@};

%trailer% @{

	int
	parse(struct lex_state *lex_state,
		int (*dispatch)(struct code *))
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);
		assert(dispatch != NULL);

		act_state->dispatch = dispatch;
		lex_state->p = lex_state->buf;

		do {
			act_state->e = ERR_NONE;

			ADVANCE_LEXER;

			p_script(lex_state, act_state);
			if (CURRENT_TERMINAL == @$error) {
				/* lexer error (e.g. fgets failing) */
				return -1;
			}

			if (act_state->e == ERR_ERRNO) {
				/* dispatch error */
				return -1;
			}

			if (act_state->e == ERR_SYNTAX) {
				if (debug & DEBUG_ACT) {
					fprintf(stderr, "<panic mode> ...\n");
				}

				/* panic mode */
				while (CURRENT_TERMINAL != @$semi && CURRENT_TERMINAL != @$nl) {
					ADVANCE_LEXER;
					if (CURRENT_TERMINAL == @$error) {
						return -1;
					}
				}

				if (debug & DEBUG_ACT) {
					fprintf(stderr, "... <end panic>\n");
				}
			}
		} while (act_state->e == ERR_SYNTAX);

		return 0;
	}

@}, @{

@};

