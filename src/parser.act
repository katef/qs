%prefixes%

	terminal = tok_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	frame  -> frame;
	type   -> type;
	code   -> code;

%header% @{

	#include <assert.h>
	#include <stdio.h>

	#include "lex.h"
	#include "code.h"
	#include "frame.h"
	#include "parser.h"

	struct act_string {
		const char *s;
		const char *e;
	};

	struct act_state {
		struct lex_tok t;
		enum lex_type type, save;
		struct frame *frame;
		int (*dispatch)(FILE *, struct frame *, struct code **);
		int (*populate)(struct frame *);
		struct code *args;
	};

	typedef struct act_string string;
	typedef enum code_type type;
	typedef struct code *code;

	#define CURRENT_TERMINAL act_state->type
	#define ERROR_TERMINAL   tok_error
	#define ADVANCE_LEXER    lex_next(lex_state, &act_state->t); \
							 act_state->type = act_state->t.type;
	#define SAVE_LEXER(tok)  act_state->save = tok;
	#define RESTORE_LEXER    act_state->type = act_state->save;

@}, @{

	#include <stdio.h>

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;

	int
	parse(struct lex_state *l,
		int (*populate)(struct frame *),
		int (*dispatch)(FILE *, struct frame *, struct code **),
		struct code *args);

@};

%terminals%

	str: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;
	@};

	var: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;
	@};

%actions%

	<dispatch>: (c :code &) -> () = @{
		assert(act_state->frame != NULL);

		if (-1 == act_state->dispatch(stdout, act_state->frame, @&c)) {
			@!;
		}

		/* TODO: if <dispatch> modifies @c then @c should be empty if successful */

		code_free(@c);
	@};

	<populate>: () -> () = @{
		assert(act_state->frame != NULL);

		if (-1 == act_state->populate(act_state->frame)) {
			@!;
		}

		if (!frame_set(act_state->frame, 1, "*", act_state->args)) {
			@!;
		}
	@};

	/*
	 * An anonymous block is not actually anonymous; it's a locally-scoped
	 * variable named "", which has its own code stack.
	 */
	<var-anon>: () -> (s :string) = @{
		@s.s = "";
		@s.e = @s.s;
	@};

	<var-self>: () -> (s :string) = @{
		@s.s = ".";
		@s.e = @s.s + 1;
	@};

	<var-top>:  () -> (s :string) = @{
		@s.s = "_";
		@s.e = @s.s + 1;
	@};

	<empty>: () -> (c :code) = @{
		@c = NULL;
	@};

	<type-null>: () -> (t :type) = @{ @t = CODE_NULL; @};
	<type-not>:  () -> (t :type) = @{ @t = CODE_NOT;  @};
	<type-call>: () -> (t :type) = @{ @t = CODE_CALL; @};
	<type-exec>: () -> (t :type) = @{ @t = CODE_EXEC; @};
	<type-if>:   () -> (t :type) = @{ @t = CODE_IF;   @};
	<type-join>: () -> (t :type) = @{ @t = CODE_JOIN; @};
	<type-pipe>: () -> (t :type) = @{ @t = CODE_PIPE; @};
	<type-set>:  () -> (t :type) = @{ @t = CODE_SET;  @};

	/* XXX: ugly
	struct code **tail;
	for (tail = @&c; *tail != NULL; tail = &(*tail)->next)
		;
	*/

	<push-data>: (c :code &, s :string) -> () = @{
		assert(@&c != NULL);
		assert(@s.s != NULL && @s.e != NULL);
		assert(@s.e > @s.s);

		if (!code_data(@&c, @s.e - @s.s, @s.s)) {
			@!;
		}
	@};

	<push-code>: (c :code &, t :type) -> () = @{
		assert(@&c != NULL);
		assert(act_state->frame != NULL);

		if (!code_push(@&c, @t, act_state->frame)) {
			@!;
		}
	@};

	<frame-push>: () -> () = @{
		if (!frame_push(&act_state->frame)) {
			@!;
		}
	@};

	<frame-pop>: () -> () = @{
		assert(act_state->frame != NULL);

		(void) frame_pop(&act_state->frame);
	@};

	<frame-set>: (s :string, c :code) -> () = @{
		assert(act_state->frame != NULL);
		assert(@s.s != NULL && @s.e != NULL);
		assert(@s.e > @s.s);

		if (!frame_set(act_state->frame, @s.e - @s.s, @s.s, @c)) {
			@!;
		}
	@};

%trailer% @{

	int
	parse(struct lex_state *lex_state,
		int (*populate)(struct frame *),
		int (*dispatch)(FILE *, struct frame *, struct code **),
		struct code *args)
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);
		assert(dispatch != NULL);
		assert(populate != NULL);

		act_state->dispatch = dispatch;
		act_state->populate = populate;

		act_state->args  = args;
		act_state->frame = NULL;

		lex_state->p = lex_state->buf;

		ADVANCE_LEXER;  /* XXX: what if the first token is unrecognised? */

		/* TODO: handle raising an error or ## */
		p_script(lex_state, act_state);

		return 0;
	}

@}, @{

@};

