%prefixes%

	terminal = tok_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	frame  -> frame;
	ast    -> ast;
	list   -> list;

%header% @{

	#include <assert.h>
	#include <stdio.h>

	#include "lex.h"
	#include "ast.h"
	#include "list.h"
	#include "frame.h"
	#include "parser.h"

	struct act_string {
		const char *s;
		const char *e;
	};

	struct act_state {
		struct lex_tok t;
		enum lex_type type, save;
		struct frame *f;
		int (*dispatch)(FILE *f, struct ast *);
		int (*populate)(struct frame *f);
		struct ast *args;
	};

	typedef struct act_string string;
	typedef struct ast_list * list;

	#define CURRENT_TERMINAL act_state->type
	#define ERROR_TERMINAL   tok_error
	#define ADVANCE_LEXER    lex_next(lex_state, &act_state->t); \
							 act_state->type = act_state->t.type;
	#define SAVE_LEXER(tok)  act_state->save = tok;
	#define RESTORE_LEXER    act_state->type = act_state->save;

	static struct ast *
	binop(struct frame *f, enum ast_type type, struct ast *a, struct ast *b)
	{
		assert(f != NULL);

		if (a == NULL) {
			return b;
		}

		if (b == NULL) {
			return a;
		}

		return ast_new_op(f, type, a, b);
	}

@}, @{

	#include <stdio.h>

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;
	typedef struct ast *       ast;

	int
	parse(struct lex_state *l,
		int (*populate)(struct frame *f),
		int (*dispatch)(FILE *f, struct ast *),
		struct ast_list *args);

@};

%terminals%

	str: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;
	@};

	var: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;
	@};

%actions%

	<dispatch>: (q :ast) -> () = @{
		if (-1 == act_state->dispatch(stdout, @q)) {
			@!;
		}
	@};

	<populate>: () -> () = @{
		if (-1 == act_state->populate(act_state->f)) {
			@!;
		}

		if (!frame_set(act_state->f, "*", act_state->args)) {
			@!;
		}
	@};

	<epsilon>: () -> (q :ast) = @{
		@q = NULL;
	@};

	<frame-push>: () -> () = @{
		if (!frame_push(&act_state->f)) {
			@!;
		}
	@};

	<frame-pop>: () -> () = @{
		(void) frame_pop(&act_state->f);
	@};

	<new-str>: (s :string) -> (q :ast) = @{
		@q = ast_new_leaf(AST_STR, @s.e - @s.s, @s.s);
		if (@q == NULL) {
			@!;
		}
	@};

	<new-var>: (s :string) -> (q :ast) = @{
		@q = ast_new_leaf(AST_VAR, @s.e - @s.s, @s.s);
		if (@q == NULL) {
			@!;
		}

		@q->f = act_state->f;
	@};

	<new-list>: (l :list) -> (q :ast) = @{
		@q = ast_new_list(@l);
		if (@q == NULL) {
			@!;
		}
	@};

	<block-frame>: (a :ast) -> (q :ast) = @{
		@q = ast_new_block(act_state->f, AST_BLOCK, @a);
		if (@q == NULL) {
			ast_free(@a);
			@!;
		}

		if (!frame_set(@q->f, ".", @q)) {
			ast_free(@q);
			ast_free(@a);
			@!;
		}
	@};

	<block-free>: (q :ast) -> () = @{
		assert(@q != NULL);

		if (!frame_set(@q->f, ".", NULL)) {
			ast_free(@q);
			@!;
		}

/* XXX:
		ast_free(@q);
*/
	@};

	<block-setbg>: (a :ast) -> (q :ast) = @{
		@q = ast_new_block(act_state->f, AST_SETBG, @a);
		if (@q == NULL) {
			ast_free(@a);
			@!;
		}

		/* TODO: $% as jobid */
		if (!frame_set(act_state->f, "%", NULL)) {
			@!;
		}
	@};

	<block-exec>: (l :list) -> (q :ast) = @{
		assert(@l != NULL);

		@q = ast_new_exec(act_state->f, AST_EXEC, @l);
		if (@q == NULL) {
			/* TODO: free something? */
			@!;
		}
	@};

	<binop-and>: (a :ast, b :ast) -> (q :ast) = @{
		@q = binop(act_state->f, AST_AND, @a, @b);
		if (@q == NULL) {
			ast_free(@a);
			ast_free(@b);
			@!;
		}
	@};

	<binop-or>: (a :ast, b :ast) -> (q :ast) = @{
		@q = binop(act_state->f, AST_OR, @a, @b);
		if (@q == NULL) {
			ast_free(@a);
			ast_free(@b);
			@!;
		}
	@};

	<binop-join>: (a :ast, b :ast) -> (q :ast) = @{
		@q = binop(act_state->f, AST_JOIN, @a, @b);
		if (@q == NULL) {
			ast_free(@a);
			ast_free(@b);
			@!;
		}
	@};

	<binop-pipe>: (a :ast, b :ast) -> (q :ast) = @{
		@q = binop(act_state->f, AST_PIPE, @a, @b);
		if (@q == NULL) {
			ast_free(@a);
			ast_free(@b);
			@!;
		}
	@};

	<binop-assign>: (a :ast, b :ast) -> (q :ast) = @{
		assert(@a != NULL);

		@q = ast_new_op(act_state->f, AST_ASSIGN, @a, @b);
		if (@q == NULL) {
			ast_free(@a);
			ast_free(@b);
			@!;
		}
	@};

	<binop-sep>: (a :ast, b :ast) -> (q :ast) = @{
		@q = binop(act_state->f, AST_SEP, @a, @b);
		if (@q == NULL) {
			ast_free(@a);
			ast_free(@b);
			@!;
		}
	@};

	<list-null>: () -> (l :list) = @{
		@l = NULL;
	@};

	<list-cat>: (t :list, a :ast) -> (l :list) = @{
		@l = list_cat(@t, @a);
		if (@l == NULL) {
			/* TODO: free a? */
			@!;
		}
	@};

%trailer% @{

	int
	parse(struct lex_state *lex_state,
		int (*populate)(struct frame *f),
		int (*dispatch)(FILE *f, struct ast *),
		struct ast_list *args)
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);
		assert(dispatch != NULL);
		assert(populate != NULL);

		act_state->dispatch = dispatch;
		act_state->populate = populate;

		act_state->args = ast_new_list(args);
		if (act_state->args == NULL) {
			return -1;
		}

		act_state->f = NULL;
		lex_state->p = lex_state->buf;

		ADVANCE_LEXER;  /* XXX: what if the first token is unrecognised? */

		/* TODO: handle raising an error or ## */
		p_script(lex_state, act_state);

		return 0;
	}

@}, @{

@};

