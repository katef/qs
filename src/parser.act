%prefixes%

	terminal = tok_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	type   -> type;
	code   -> code;

%header% @{

	#include <assert.h>
	#include <limits.h>
	#include <string.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <errno.h>

	#include <unistd.h>

	#include "debug.h"
	#include "lex.h"
	#include "code.h"
	#include "parser.h"

	struct act_string {
		const char *s;
		const char *e;
	};

	struct act_state {
		struct lex_tok t;
		enum lex_type type, save;
		int (*dispatch)(struct code *);
	};

	typedef struct act_string string;
	typedef enum code_type type;
	typedef struct code *code;

	#define CURRENT_TERMINAL act_state->type
	#define ERROR_TERMINAL   tok_error
	#define ADVANCE_LEXER    lex_next(lex_state, &act_state->t); \
							 act_state->type = act_state->t.type;
	#define SAVE_LEXER(tok)  act_state->save = tok;
	#define RESTORE_LEXER    act_state->type = act_state->save;

	static void
	err_syntax(const struct lex_state *lex_state,
		const char *msg)
	{
		assert(lex_state != NULL);

		fprintf(stderr, "syntax error: ");

		if (msg != NULL) {
			fprintf(stderr, "%s", msg);
		}

		fprintf(stderr, "\n");

		/*
		 * The lexer's buffer is a line at a time. Here we assume that the
		 * start of the buffer is always the start of a line, and so pos.col
		 * gives the start of the unexpected token.
		 *
		 * For a block-at-a-time lexer, I would prefix "..." if the buffer
		 * were not at the start of a line.
		 */

		/* TODO: conditionally on DEBUG_SRC (default to true) */
		{
			size_t i;
			int r;

			r = fprintf(stderr, "at %lu:%lu: ", lex_state->pos.line, lex_state->pos.col);
			if (r < 0) {
				perror("fprintf");
				return;
			}

			fprintf(stderr, "%.*s\n", (int) strcspn(lex_state->buf, "\n"), lex_state->buf);

			for (i = 0; (int) i < r; i++) {
				fprintf(stderr, "-");
			}

			for (i = 1; i < lex_state->pos.col; i++) {
				fprintf(stderr, "-");
			}

			fprintf(stderr, "^\n");
		}
	}

@}, @{

	#include <stdio.h>

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;

	int
	parse(struct lex_state *l,
		int (*dispatch)(struct code *));

@};

%terminals%

	word: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "str: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

	var: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "var: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

%actions%

	<dispatch>: (c :code &) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<dispatch>: ");
			code_dump(stderr, @c);
		}

		if (-1 == act_state->dispatch(@c)) {
			@!;
		}
	@};

	<empty-code>: () -> (c :code) = @{
		@c = NULL;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<empty-code>\n");
		}
	@};

	<stdin>:  () -> (s :string) = @{ @s.s = "0"; @s.e = @s.s + 1; @};
	<stdout>: () -> (s :string) = @{ @s.s = "1"; @s.e = @s.s + 1; @};
	<stderr>: () -> (s :string) = @{ @s.s = "2"; @s.e = @s.s + 1; @};

	<type-call>: () -> (t :type) = @{ @t = CODE_CALL; @};
	<type-join>: () -> (t :type) = @{ @t = CODE_JOIN; @};
	<type-not>:  () -> (t :type) = @{ @t = CODE_NOT;  @};
	<type-null>: () -> (t :type) = @{ @t = CODE_NULL; @};
	<type-run>:  () -> (t :type) = @{ @t = CODE_RUN;  @};
	<type-tick>: () -> (t :type) = @{ @t = CODE_TICK; @};
	<type-push>: () -> (t :type) = @{ @t = CODE_PUSH; @};
	<type-pop>:  () -> (t :type) = @{ @t = CODE_POP;  @};
	<type-clhs>: () -> (t :type) = @{ @t = CODE_CLHS; @};
	<type-crhs>: () -> (t :type) = @{ @t = CODE_CRHS; @};
	<type-ctck>: () -> (t :type) = @{ @t = CODE_CTCK; @};

	<type-data>: () -> (t :type) = @{ @t = CODE_DATA; @};
	<type-dup>:  () -> (t :type) = @{ @t = CODE_DUP;  @};
	<type-asc>:  () -> (t :type) = @{ @t = CODE_ASC;  @};
	<type-if>:   () -> (t :type) = @{ @t = CODE_IF;   @};
	<type-pipe>: () -> (t :type) = @{ @t = CODE_PIPE; @};
	<type-set>:  () -> (t :type) = @{ @t = CODE_SET;  @};

	<code-anon>: (c :code &, t :type, ci :code) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-anon>\n");
		}

		/* XXX: leak */
		if (!code_anon(@&c, &lex_state->pos, @t, @ci)) {
			@!;
		}
	@};

	<code-data>: (c :code &, s :string) -> () = @{
		assert(@s.s != NULL && @s.e != NULL);
		assert(@s.e >= @s.s);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-data>: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}

		if (!code_data(@&c, &lex_state->pos, @s.e - @s.s, @s.s)) {
			@!;
		}
	@};

	<code-push>: (c :code &, t :type) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-push>: %s\n", code_name(@t));
		}

		if (!code_push(@&c, &lex_state->pos, @t)) {
			@!;
		}
	@};

	<code-wind>: (c :code &, ci :code) -> () = @{
		struct code **tail;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-wind>\n");
		}

		for (tail = @&ci; *tail != NULL; tail = &(*tail)->next)
			;

		*tail = @c;
		@=c = @ci;
	@};

	<err-expected-sep> = @{
		err_syntax(lex_state, "expected { '\\n' | ';' | '&' }");
		@!;
	@};

	<err-syntax> = @{
		err_syntax(lex_state, NULL);
		@!;
	@};

%trailer% @{

	int
	parse(struct lex_state *lex_state,
		int (*dispatch)(struct code *))
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);
		assert(dispatch != NULL);

		act_state->dispatch = dispatch;
		lex_state->p = lex_state->buf;

		ADVANCE_LEXER;  /* XXX: what if the first token is unrecognised? */

		/* TODO: handle raising an error or ## */
		p_script(lex_state, act_state);

		return 0;
	}

@}, @{

@};

