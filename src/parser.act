%prefixes%

	terminal = tok_;
	function = p_;

%persistents%

	lex_state :lex_state;
	act_state :act_state;

%maps%

	string -> string;
	type   -> type;
	code   -> code;

%header% @{

	#include <assert.h>
	#include <limits.h>
	#include <string.h>
	#include <stdlib.h>
	#include <stdio.h>
	#include <errno.h>

	#include <unistd.h>

	#include "debug.h"
	#include "lex.h"
	#include "code.h"
	#include "frame.h"
	#include "parser.h"

	struct act_string {
		const char *s;
		const char *e;
	};

	struct act_state {
		struct lex_tok t;
		enum lex_type type, save;
		struct frame *top;
		int (*dispatch)(struct frame *, struct code *);
	};

	typedef struct act_string string;
	typedef enum code_type type;
	typedef struct code *code;

	#define CURRENT_TERMINAL act_state->type
	#define ERROR_TERMINAL   tok_error
	#define ADVANCE_LEXER    lex_next(lex_state, &act_state->t); \
							 act_state->type = act_state->t.type;
	#define SAVE_LEXER(tok)  act_state->save = tok;
	#define RESTORE_LEXER    act_state->type = act_state->save;

@}, @{

	#include <stdio.h>

	typedef struct lex_state * lex_state;
	typedef struct act_state * act_state;

	int
	parse(struct lex_state *l,
		int (*dispatch)(struct frame *, struct code *),
		struct frame *top);

@};

%terminals%

	word: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "str: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

	var: () -> (s :string) = @{
		assert(act_state->t.s != NULL);
		assert(act_state->t.e >= act_state->t.s);

		@s.s = act_state->t.s;
		@s.e = act_state->t.e;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "var: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}
	@};

%actions%

	<dispatch>: (c :code &) -> () = @{
		assert(act_state->top != NULL);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<dispatch>: ");
			code_dump(stderr, @c);
		}

		if (-1 == act_state->dispatch(act_state->top, @c)) {
			@!;
		}
	@};

	<empty-code>: () -> (c :code) = @{
		@c = NULL;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<empty-code>\n");
		}
	@};

	<stdin>:  () -> (s :string) = @{ @s.s = "0"; @s.e = @s.s + 1; @};
	<stdout>: () -> (s :string) = @{ @s.s = "1"; @s.e = @s.s + 1; @};
	<stderr>: () -> (s :string) = @{ @s.s = "2"; @s.e = @s.s + 1; @};

	<type-call>: () -> (t :type) = @{ @t = CODE_CALL; @};
	<type-join>: () -> (t :type) = @{ @t = CODE_JOIN; @};
	<type-not>:  () -> (t :type) = @{ @t = CODE_NOT;  @};
	<type-null>: () -> (t :type) = @{ @t = CODE_NULL; @};
	<type-run>:  () -> (t :type) = @{ @t = CODE_RUN;  @};
	<type-tick>: () -> (t :type) = @{ @t = CODE_TICK; @};
	<type-push>: () -> (t :type) = @{ @t = CODE_PUSH; @};
	<type-pop>:  () -> (t :type) = @{ @t = CODE_POP;  @};
	<type-clhs>: () -> (t :type) = @{ @t = CODE_CLHS; @};
	<type-crhs>: () -> (t :type) = @{ @t = CODE_CRHS; @};
	<type-ctck>: () -> (t :type) = @{ @t = CODE_CTCK; @};

	<type-data>: () -> (t :type) = @{ @t = CODE_DATA; @};
	<type-dup>:  () -> (t :type) = @{ @t = CODE_DUP;  @};
	<type-asc>:  () -> (t :type) = @{ @t = CODE_ASC;  @};
	<type-if>:   () -> (t :type) = @{ @t = CODE_IF;   @};
	<type-pipe>: () -> (t :type) = @{ @t = CODE_PIPE; @};
	<type-set>:  () -> (t :type) = @{ @t = CODE_SET;  @};

	<code-anon>: (c :code &, t :type, ci :code) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-anon>\n");
		}

		/* XXX: leak */
		if (!code_anon(@&c, &lex_state->pos, @t, @ci)) {
			@!;
		}
	@};

	<code-data>: (c :code &, s :string) -> () = @{
		assert(@s.s != NULL && @s.e != NULL);
		assert(@s.e >= @s.s);

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-data>: \"%.*s\"\n", (int) (@s.e - @s.s), @s.s);
		}

		if (!code_data(@&c, &lex_state->pos, @s.e - @s.s, @s.s)) {
			@!;
		}
	@};

	<code-push>: (c :code &, t :type) -> () = @{
		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-push>: %s\n", code_name(@t));
		}

		if (!code_push(@&c, &lex_state->pos, @t)) {
			@!;
		}
	@};

	<code-wind>: (c :code &, ci :code) -> () = @{
		struct code **tail;

		if (debug & DEBUG_ACT) {
			fprintf(stderr, "<code-wind>\n");
		}

		for (tail = @&ci; *tail != NULL; tail = &(*tail)->next)
			;

		*tail = @c;
		@=c = @ci;
	@};

	<err-expected-sep>: () -> () = @{
		fprintf(stderr, "syntax error: expected { '\\n' | ';' | '&' }\n");
		@!;
	@};

	<err-syntax>: (c :code) -> () = @{
		fprintf(stderr, "syntax error\n");
		/* TODO:
		fprintf(stderr, "syntax error at: ");
		code_dump(stderr, @c);
		*/
		@!;
	@};

%trailer% @{

	int
	parse(struct lex_state *lex_state,
		int (*dispatch)(struct frame *, struct code *),
		struct frame *top)
	{
		struct act_state a, *act_state = &a;

		assert(lex_state != NULL);
		assert(dispatch != NULL);

		act_state->dispatch = dispatch;
		act_state->top      = top;
		lex_state->p        = lex_state->buf;

		ADVANCE_LEXER;  /* XXX: what if the first token is unrecognised? */

		/* TODO: handle raising an error or ## */
		p_script(lex_state, act_state);

		return 0;
	}

@}, @{

@};

