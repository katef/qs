%types%

	string;
	!frame;
	ast;
	list;

%terminals%

	!error;
	!panic;

	eof;
	nl;
	semi;
	bg;
	equ;
	!dot;
	!back;
	pipe;
	obrace;
	cbrace;
	oparen;
	cparen;
	or;
	and;
	!exec;

	str: () -> (:string);
	var: () -> (:string);

%productions%

	<dispatch>: (:ast) -> ();
	<populate>;

	<epsilon>: () -> (:ast);

    <frame-push>;
    <frame-pop>;

	<new-str>:  (:string) -> (:ast);
	<new-var>:  (:string) -> (:ast);
	<new-list>: (:list)   -> (:ast);

	<block-frame>: (:ast)  -> (:ast);
	<block-free>:  (:ast)  -> ();
	<block-setbg>: (:ast)  -> (:ast);
	<block-exec>:  (:list) -> (:ast);

	<binop-and>:    (:ast, :ast) -> (:ast);
	<binop-or>:     (:ast, :ast) -> (:ast);
	!<binop-join>:  (:ast, :ast) -> (:ast);
	<binop-pipe>:   (:ast, :ast) -> (:ast);
	<binop-assign>: (:ast, :ast) -> (:ast);
	<binop-sep>:    (:ast, :ast) -> (:ast);

	<list-null>: () -> (:list);
	<list-cat>:  (:list, :ast) -> (:list);

	exprs:    () -> (:ast);
	ast-list: () -> (:list);

	compound-expr: () -> (q :ast) = {
		oparen;
		l = ast-list;
		q = <new-list>(l);
		cparen;
	||
		obrace;
		<frame-push>;
		a = exprs;
		q = <block-frame>(a);
		<frame-pop>;
		cbrace;
	};

	ast-list: () -> (l :list) = {
		/* TODO: || backtick */
		{
			s = str;
			a = <new-str>(s);
		||
			s = var;
			a = <new-var>(s);
		||
			a = compound-expr;
		};

		{
			t = ast-list;
		||
			t = <list-null>;
		};

		l = <list-cat>(t, a);
	};

	cmd: () -> (q :ast) [

		value: () -> (q :ast) = {
			q = compound-expr;
		||
			s = str;
			q = <new-str>(s);
		||
			s = var;
			q = <new-var>(s);
		};

	] = {
		q = compound-expr;
	||
		l = ast-list;
		q = <block-exec>(l);
	||
		s = str;
		a = <new-str>(s);
		equ;
		b = value;
		q = <binop-assign>(a, b);
	};

/* XXX: needs different grammar */
	assign-expr: () -> (q :ast) = {
		q = cmd;
	};

	pipe-expr: () -> (q :ast) = {
		a = assign-expr;

		{
			pipe;
			b = pipe-expr;
		||
			b = <epsilon>;
		};

		q = <binop-pipe>(a, b);
	};

	and-expr: () -> (q :ast) = {
		a = pipe-expr;

		{
			and;
			b = and-expr;
		||
			b = <epsilon>;
		};

		q = <binop-and>(a, b);
	};

	or-expr: () -> (q :ast) = {
		a = and-expr;

		{
			or;
			b = or-expr;
		||
			b = <epsilon>;
		};

		q = <binop-or>(a, b);
	};

	exprs: () -> (q :ast) [

		::expr: () -> (q :ast) = {
			a = or-expr;

			{
				nl;
				q = a;
			||
				semi;
				q = a;
			||
				bg;
				q = <block-setbg>(a);
			};
		||
			q = <epsilon>;
			nl;
		||
			q = <epsilon>;
			semi;
		};

	] = {
		a = expr;

		{
			b = exprs;
		||
			b = <epsilon>;
		};

		q = <binop-sep>(a, b);
	};

	script [

		global-exprs = {
			a = expr;

			<dispatch>(a);

			<block-free>(a);

			{
				global-exprs;
			||
				$;
			};
		};

	] = {
		<frame-push>;
		<populate>;
		global-exprs;
		<frame-pop>;

		eof;
	};

%entry%

	script;

