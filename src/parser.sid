%types%

	string;
	type;
	code;

%terminals%

	!error;
	!panic;

	!eof;
	nl;
	semi;
	!bg;
	equ;
	comma;
	!dot;
	tick;
	bar;
	obrace;  cbrace;
	oparen;  cparen;
	osquare; csquare;
	or;
	and;
	!exec;

	word: () -> (:string);
	var:  () -> (:string);

%productions%

	<empty-code>: () -> (:code);

	<stdin>:  () -> (:string);
	!<stdout>:() -> (:string);
	!<stderr>:() -> (:string);

	<type-call>: () -> (:type);
	!<type-join>:() -> (:type);
	<type-not>:  () -> (:type);
	<type-null>: () -> (:type);
	<type-run>:  () -> (:type);
	<type-push>: () -> (:type);
	<type-pop>:  () -> (:type);
	<type-clhs>: () -> (:type);
	<type-crhs>: () -> (:type);
	<type-ctck>: () -> (:type);

	!<type-data>:() -> (:type);
	<type-dup>:  () -> (:type);
	<type-asc>:  () -> (:type);
	<type-if>:   () -> (:type);
	<type-pipe>: () -> (:type);
	<type-set>:  () -> (:type);
	<type-tick>: () -> (:type);

	<code-anon>: (:code &, :type, :code) -> ();
	<code-data>: (:code &, :string)      -> ();
	<code-push>: (:code &, :type)        -> ();
	<code-wind>: (:code &, :code)        -> ();

	<err-expected-sep>;
	<err-syntax>: (:code) -> ();

	block:     () -> (:code);
	expr-list: () -> (:code);

	concat: (a :code, b :code) -> (q :code) = {
		q = <empty-code>;

		<code-wind>(&q, b);
		<code-wind>(&q, a);
	};

	frame: (ci :code) -> (c :code) = {
		c = <empty-code>;

		t0 = <type-pop>;
		<code-push>(&c, t0);

		<code-wind>(&c, ci);

		t1 = <type-push>;
		<code-push>(&c, t1);
	};

	pipe: (lhs :code, rhs :code) -> (c :code) [

		side: (t :type, ci :code) -> (c :code) = {
			t0 = <type-dup>;

			<code-push>(&ci, t0);

			cx = <empty-code>;

			<code-push>(&cx, t);
			<code-wind>(&cx, ci);

			c = frame(cx);
		};

	] = {
		t1 = <type-clhs>;
		t2 = <type-crhs>;

		l = side(t1, lhs);
		c = side(t2, rhs);

		t0 = <type-pipe>;
		<code-anon>(&c, t0, l);
	};

	list: () -> (c :code) [

		::item: () -> (c :code) = {
			s = word;

			c = <empty-code>;
			<code-data>(&c, s);
		||
			s = var;

			c = <empty-code>;
			t = <type-call>;
			<code-push>(&c, t);
			<code-data>(&c, s);
		||
			tick;

			/* tick command */
			{
				cx = item;

				ci = <empty-code>;

				t1 = <type-run>;
				<code-push>(&ci, t1);

				<code-wind>(&ci, cx);

				t0 = <type-null>;
				<code-push>(&ci, t0);
			||
				ci = block;
			};

			{
				lhs = <empty-code>;

				t4 = <type-ctck>;
				<code-push>(&lhs, t4);

				<code-wind>(&lhs, ci);
			};

			{
				rhs = <empty-code>;

				t3 = <type-tick>;
				<code-push>(&rhs, t3);
			};

			c = pipe(lhs, rhs);
		};

	] = {
		c = item;

		{
			ci = list;
			<code-wind>(&c, ci);
		||
			$;
		};
	};

	assign-expr: () -> (c :code) [

		value: () -> (c :code) = {
			oparen;
			c = list;
			cparen;
		||
			c = item;
		||
			c = block;
		};

	] = {
		s = word;
		equ;
		ci = value;

		c = <empty-code>;

		t = <type-set>;
		<code-anon>(&c, t, ci);

		<code-data>(&c, s);
	};

	block: () -> (c :code) = {
		obrace;
		{
			c = expr-list;
		||
			c = <empty-code>;
		};
		cbrace;
	};

	command: () -> (c :code) = {
		cx = list;

		c = <empty-code>;

		t0 = <type-run>;
		<code-push>(&c, t0);

		<code-wind>(&c, cx);

		t1 = <type-null>;
		<code-push>(&c, t1);
	};

	dup-expr: () -> (c :code) [

		/* here I would use zones if the lexer supported it, and emit tok_fd */
		fd: () -> (c :code) = {
			s = word;

			c = <empty-code>;
			<code-data>(&c, s);
		||
			s = var;

			c = <empty-code>;
			t = <type-call>;
			<code-push>(&c, t);
			<code-data>(&c, s);
		};

		close: () -> (c :code) = {
			c = <empty-code>;
			t = <type-null>;
			<code-push>(&c, t);
		};

		default: () -> (c :code) = {
			c = <empty-code>;
			s = <stdin>;
			<code-data>(&c, s);
		};

		dup-pair: () -> (old :code, new :code) = {
			old = fd;
			equ;
			new = fd;
		||
			old = fd;
			equ;
			new = close;
		||
			old = fd;
			new = default;
		};

		asc-pair: () -> (lhs :code, rhs :code) = {
			lhs = fd;
			bar;
			rhs = fd;
		};

		pair-list: () -> (c :code) = {
			{
				(m, n) = dup-pair;
				t0 = <type-dup>;
			||
				(m, n) = asc-pair;
				t0 = <type-asc>;
			};

			{
				comma;
				c = pair-list;
			||
				c = <empty-code>;
			};

			/*
			 * Because we recurr leftmost, the pair list is pushed after parse,
			 * so that latter pairs may evaluate to overwrite previous pairs.
			 */

			<code-push>(&c, t0);

			<code-wind>(&c, m);
			<code-wind>(&c, n);

			t1 = <type-null>;
			<code-push>(&c, t1);
		};

		pair-box: () -> (c :code) = {
			osquare;
			dx = pair-list;
			csquare;

			c = <empty-code>;

			<code-wind>(&c, dx);
		};

	] = {
		cx = block;

		/*
		 * Here we need a frame for the block regardless of whether
		 * there is a redir list present. If there is a redir list then
		 * the block's frame is used to hold it. Otherwise, a frame
		 * is pushed anyway for scoping (with an empty dup and asc list).
		 */
		{
			d = pair-box;
			q = concat(d, cx);
			c = frame(q);
		||
			d = <empty-code>;
			q = concat(d, cx);
			c = frame(q);
		};
	||
		cx = command;

		/*
		 * Here we only push a frame if there is a dup list to hold.
		 */
		{
			d = pair-box;
			q = concat(d, cx);
			c = frame(q);
		||
			c = cx;
		};
	};

	pipe-expr: () -> (c :code) = {
		cx = dup-expr;

		{
			bar;

			rhs = pipe-expr;
			lhs = cx;

			c = pipe(lhs, rhs);
		||
			c = cx;
		};
	};

	and-expr: () -> (c :code) = {
		{
			cx = pipe-expr;
		||
			cx = assign-expr;
		};

		{
			and;

			ci = and-expr;

			c = <empty-code>;

			t2 = <type-if>;
			<code-anon>(&c, t2, ci);

			<code-wind>(&c, cx);
		||
			c = cx;
		};
	};

	or-expr: () -> (c :code) = {
		cx = and-expr;

		{
			or;

			ci = or-expr;

			c = <empty-code>;

			t2 = <type-if>;
			<code-anon>(&c, t2, ci);

			t1 = <type-not>;
			<code-push>(&c, t1);

			<code-wind>(&c, cx);
		||
			c = cx;
		};
	};

	expr-list: () -> (c :code) [

		::sep = {
			nl;
		||
			semi;
		##
			<err-expected-sep>;
		};

		::expr: () -> (c :code) = {
			c = or-expr;
		##
			c = <empty-code>;
			<err-syntax>(c);
		};

	] = {
		cx = expr;

		{
			sep;

			c = expr-list;

			<code-wind>(&c, cx);
		||
			sep;
			c = cx;
		||
			c = cx;
		};
	};

	global-expr-list: () -> (c :code) = {
		{
			sep;
		||
			$;
		};

		{
			c = expr;
		||
			c = <empty-code>;
		};
	};

%entry%

	global-expr-list;

