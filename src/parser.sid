%types%

	string;
	!frame;
	type;
	code;

%terminals%

	!error;
	!panic;

	eof;
	nl;
	semi;
	!bg;
	equ;
	comma;
	!dot;
	tick;
	bar;
	obrace;  cbrace;
	oparen;  cparen;
	osquare; csquare;
	or;
	and;
	!exec;

	word: () -> (:string);
	var:  () -> (:string);

%productions%

	<dispatch>: (:code &) -> ();

	<var-top>:  () -> (:string);

	<empty-code>: () -> (:code);

	<stdin>:  () -> (:string);
	!<stdout>:() -> (:string);
	!<stderr>:() -> (:string);

	<type-call>: () -> (:type);
	!<type-join>:() -> (:type);
	<type-not>:  () -> (:type);
	<type-null>: () -> (:type);
	<type-run>:  () -> (:type);
	<type-push>: () -> (:type);
	<type-pop>:  () -> (:type);

	!<type-data>:() -> (:type);
	<type-dup>:  () -> (:type);
	<type-if>:   () -> (:type);
	<type-pipe>: () -> (:type);
	<type-set>:  () -> (:type);
	<type-tick>: () -> (:type);

	<code-anon>: (:code &, :type, :code) -> ();
	<code-data>: (:code &, :string)      -> ();
	<code-push>: (:code &, :type)        -> ();
	<code-wind>: (:code &, :code)        -> ();

	<err-expected-sep>;
	<err-syntax>: (:code) -> ();

	block:     () -> (:code);
	expr-list: () -> (:code);

	list: () -> (c :code) [

		::item: () -> (c :code) = {
			s = word;

			c = <empty-code>;
			<code-data>(&c, s);
		||
			s = var;

			c = <empty-code>;
			t = <type-call>;
			<code-push>(&c, t);
			<code-data>(&c, s);
		||
			tick;

			{
				cx = item;

				c = <empty-code>;

				t5 = <type-run>;
				<code-push>(&c, t5);

				<code-wind>(&c, cx);

				t0 = <type-null>;
				<code-push>(&c, t0);
			||
				c = block;
			};

			/* tick rhs */
			{
				ci = <empty-code>;

				t3 = <type-tick>;
				<code-push>(&ci, t3);
			};

			t2 = <type-pipe>;
			<code-anon>(&c, t2, ci);
		};

	] = {
		c = item;

		{
			ci = list;
			<code-wind>(&c, ci);
		||
			$;
		};
	};

	assign-expr: () -> (c :code) [

		value: () -> (c :code) = {
			oparen;
			c = list;
			cparen;
		||
			c = item;
		||
			c = block;
		};

	] = {
		s = word;
		equ;
		ci = value;

		c = <empty-code>;

		t1 = <type-set>;
		<code-anon>(&c, t1, ci);

		<code-data>(&c, s);

		t2 = <type-null>;
		<code-push>(&c, t2);
	};

	block: () -> (c :code) = {
		obrace;
		{
			c = expr-list;
		||
			c = <empty-code>;
		};
		cbrace;
	};

	command: () -> (c :code) = {
		cx = list;

		c = <empty-code>;

		t0 = <type-run>;
		<code-push>(&c, t0);

		<code-wind>(&c, cx);

		t1 = <type-null>;
		<code-push>(&c, t1);
	};

	dup-expr: () -> (c :code) [

		/* here I would use zones if the lexer supported it, and emit tok_fd */
		/* TODO: permit [$x=$y] here */
		dup-item: (c :code &) -> () = {
			l = word;
			equ;
			r = word;

			<code-data>(&c, r);
			<code-data>(&c, l);
		||
			l = word;
			equ;

			t = <type-null>;
			<code-push>(&c, t);
			<code-data>(&c, l);
		||
			l = word;
			r = <stdin>;

			<code-data>(&c, r);
			<code-data>(&c, l);
		};

		dup-list: (c :code &) -> () = {
			dup-item(&c);

			{
				comma;
				dup-list(&c);
			||
				$;
			};
		};

		dup: () -> (c :code) = {
			c = <empty-code>;

			osquare;
			dup-list(&c);
			csquare;

			t = <type-dup>;
			<code-push>(&c, t);
		};

		frame: (dx :code, cx :code) -> (c :code) = {
			c = <empty-code>;

			t0 = <type-pop>;
			<code-push>(&c, t0);

			<code-wind>(&c, cx);
			<code-wind>(&c, dx);

			t1 = <type-push>;
			<code-push>(&c, t1);
		};

	] = {
		cx = block;

		/*
		 * Here we need a frame for the block regardless of whether
		 * there is a dup list present. If there is a dup list then
		 * the block's frame is used to hold it. Otherwise, a frame
		 * is pushed anyway for scoping (with an empty dup list).
		 */
		{
			d = dup;
			c = frame(d, cx);
		||
			d = <empty-code>;
			c = frame(d, cx);
		};
	||
		cx = command;

		/*
		 * Here we only push a frame if there is a dup list to hold.
		 */
		{
			d = dup;
			c = frame(d, cx);
		||
			c = cx;
		};
	};

	pipe-expr: () -> (c :code) = {
		c = dup-expr;

		{
			bar;

			ci = pipe-expr;

			t2 = <type-pipe>;
			<code-anon>(&c, t2, ci);
		||
			$;
		};
	};

	and-expr: () -> (c :code) = {
		{
			cx = pipe-expr;
		||
			cx = assign-expr;
		};

		{
			and;

			ci = and-expr;

			c = <empty-code>;

			t2 = <type-if>;
			<code-anon>(&c, t2, ci);

			<code-wind>(&c, cx);
		||
			c = cx;
		};
	};

	or-expr: () -> (c :code) = {
		cx = and-expr;

		{
			or;

			ci = or-expr;

			c = <empty-code>;

			t1 = <type-not>;
			<code-push>(&c, t1);

			t2 = <type-if>;
			<code-anon>(&c, t2, ci);

			<code-wind>(&c, cx);
		||
			c = cx;
		};
	};

	expr-list: () -> (c :code) [

		::sep = {
			nl;
		||
			semi;
		##
			<err-expected-sep>;
		};

		::expr: () -> (c :code) = {
			c = or-expr;
		##
			c = <empty-code>;
			<err-syntax>(c);
		};

	] = {
		cx = expr;

		{
			sep;

			c = expr-list;

			<code-wind>(&c, cx);
		||
			sep;
			c = cx;
		||
			c = cx;
		};
	};

	script [

		global-expr-list = {
			c = expr;
			sep;

			t1 = <type-set>;
			<code-anon>(&c, t1, c);

			s = <var-top>;
			<code-data>(&c, s);

			t2 = <type-null>;
			<code-push>(&c, t2);

			<dispatch>(&c);

			{
				global-expr-list;
			||
				$;
			};
		};

	] = {
		{
			global-expr-list;
		||
			$;
		};

		eof;
	};

%entry%

	script;

