%types%

	string;
	type;
	code;

%terminals%

	!error;
	!panic;

	eof;
	nl;
	semi;
	!bg;
	equ;
	comma;
	!dot;
	tick;
	bar;
	obrace;  cbrace;
	oparen;  cparen;
	osquare; csquare;
	or;
	and;
	!exec;

	word: () -> (:string);
	var:  () -> (:string);

%productions%

	<dispatch>: (:code &) -> ();

	<var-top>:  () -> (:string);

	<empty-code>: () -> (:code);

	<stdin>:  () -> (:string);
	!<stdout>:() -> (:string);
	!<stderr>:() -> (:string);

	<type-call>: () -> (:type);
	!<type-join>:() -> (:type);
	<type-not>:  () -> (:type);
	<type-null>: () -> (:type);
	<type-run>:  () -> (:type);
	<type-push>: () -> (:type);
	<type-pop>:  () -> (:type);
	<type-lhs>:  () -> (:type);
	<type-rhs>:  () -> (:type);

	!<type-data>:() -> (:type);
	<type-dup>:  () -> (:type);
	<type-if>:   () -> (:type);
	<type-pipe>: () -> (:type);
	<type-set>:  () -> (:type);
	<type-tick>: () -> (:type);

	<code-anon>: (:code &, :type, :code) -> ();
	<code-data>: (:code &, :string)      -> ();
	<code-push>: (:code &, :type)        -> ();
	<code-wind>: (:code &, :code)        -> ();

	<err-expected-sep>;
	<err-syntax>: (:code) -> ();

	block:     () -> (:code);
	expr-list: () -> (:code);

	concat: (a :code, b :code) -> (q :code) = {
		q = <empty-code>;

		<code-wind>(&q, b);
		<code-wind>(&q, a);
	};

	frame: (ci :code) -> (c :code) = {
		c = <empty-code>;

		t0 = <type-pop>;
		<code-push>(&c, t0);

		<code-wind>(&c, ci);

		t1 = <type-push>;
		<code-push>(&c, t1);
	};

	pipe: (lhs :code, rhs :code) -> (c :code) = {
		c = frame(lhs);
		r = frame(rhs);

		t = <type-pipe>;
		<code-anon>(&c, t, r);
	};

	list: () -> (c :code) [

		::item: () -> (c :code) = {
			s = word;

			c = <empty-code>;
			<code-data>(&c, s);
		||
			s = var;

			c = <empty-code>;
			t = <type-call>;
			<code-push>(&c, t);
			<code-data>(&c, s);
		||
			tick;

			/* tick command */
			{
				cx = item;

				ci = <empty-code>;

				t1 = <type-run>;
				<code-push>(&ci, t1);

				<code-wind>(&ci, cx);

				t0 = <type-null>;
				<code-push>(&ci, t0);
			||
				ci = block;
			};

			/* pipe rhs */
			{
				rhs = <empty-code>;

				t3 = <type-tick>;
				<code-push>(&rhs, t3);
			};

			/* pipe lhs */
			{
				lhs = ci;

				t2 = <type-lhs>;
				<code-push>(&lhs, t2);
			};

			c = pipe(lhs, rhs);
		};

	] = {
		c = item;

		{
			ci = list;
			<code-wind>(&c, ci);
		||
			$;
		};
	};

	assign-expr: () -> (c :code) [

		value: () -> (c :code) = {
			oparen;
			c = list;
			cparen;
		||
			c = item;
		||
			c = block;
		};

	] = {
		s = word;
		equ;
		ci = value;

		c = <empty-code>;

		t1 = <type-set>;
		<code-anon>(&c, t1, ci);

		<code-data>(&c, s);

		t2 = <type-null>;
		<code-push>(&c, t2);
	};

	block: () -> (c :code) = {
		obrace;
		{
			c = expr-list;
		||
			c = <empty-code>;
		};
		cbrace;
	};

	command: () -> (c :code) = {
		cx = list;

		c = <empty-code>;

		t0 = <type-run>;
		<code-push>(&c, t0);

		<code-wind>(&c, cx);

		t1 = <type-null>;
		<code-push>(&c, t1);
	};

	dup-expr: () -> (c :code) [

		/* here I would use zones if the lexer supported it, and emit tok_fd */
		fd: () -> (c :code) = {
			s = word;

			c = <empty-code>;
			<code-data>(&c, s);
		||
			s = var;

			c = <empty-code>;
			t = <type-call>;
			<code-push>(&c, t);
			<code-data>(&c, s);
		};

		close: () -> (c :code) = {
			c = <empty-code>;
			t = <type-null>;
			<code-push>(&c, t);
		};

		default: () -> (c :code) = {
			c = <empty-code>;
			s = <stdin>;
			<code-data>(&c, s);
		};

		dup-pair: () -> (old :code, new :code) = {
			old = fd;
			equ;
			new = fd;
		||
			old = fd;
			equ;
			new = close;
		||
			old = fd;
			new = default;
		};

		dup-list: () -> (c :code) = {
			(old, new) = dup-pair;

			{
				comma;
				c = dup-list;
			||
				c = <empty-code>;
			};

			/*
			 * Because we recurr leftmost, the dup list is pushed after parse,
			 * so that latter pairs may evaluate to overwrite previous pairs.
			 */

			<code-wind>(&c, old);
			<code-wind>(&c, new);
		};

		dup: () -> (c :code) = {
			osquare;
			dx = dup-list;
			csquare;

			c = <empty-code>;

			t1 = <type-dup>;
			<code-push>(&c, t1);

			<code-wind>(&c, dx);

			t0 = <type-null>;
			<code-push>(&c, t0);
		};

	] = {
		cx = block;

		/*
		 * Here we need a frame for the block regardless of whether
		 * there is a dup list present. If there is a dup list then
		 * the block's frame is used to hold it. Otherwise, a frame
		 * is pushed anyway for scoping (with an empty dup list).
		 */
		{
			d = dup;
			q = concat(d, cx);
			c = frame(q);
		||
			d = <empty-code>;
			q = concat(d, cx);
			c = frame(q);
		};
	||
		cx = command;

		/*
		 * Here we only push a frame if there is a dup list to hold.
		 */
		{
			d = dup;
			q = concat(d, cx);
			c = frame(q);
		||
			c = cx;
		};
	};

	pipe-expr: () -> (c :code) = {
		cx = dup-expr;

		{
			bar;

			/* pipe rhs */
			{
				rhs = pipe-expr;

				t3 = <type-rhs>;
				<code-push>(&rhs, t3);
			};

			/* pipe lhs */
			{
				lhs = cx;

				t2 = <type-lhs>;
				<code-push>(&lhs, t2);
			};

			c = pipe(lhs, rhs);
		||
			c = cx;
		};
	};

	and-expr: () -> (c :code) = {
		{
			cx = pipe-expr;
		||
			cx = assign-expr;
		};

		{
			and;

			ci = and-expr;

			c = <empty-code>;

			t2 = <type-if>;
			<code-anon>(&c, t2, ci);

			<code-wind>(&c, cx);
		||
			c = cx;
		};
	};

	or-expr: () -> (c :code) = {
		cx = and-expr;

		{
			or;

			ci = or-expr;

			c = <empty-code>;

			t1 = <type-not>;
			<code-push>(&c, t1);

			t2 = <type-if>;
			<code-anon>(&c, t2, ci);

			<code-wind>(&c, cx);
		||
			c = cx;
		};
	};

	expr-list: () -> (c :code) [

		::sep = {
			nl;
		||
			semi;
		##
			<err-expected-sep>;
		};

		::expr: () -> (c :code) = {
			c = or-expr;
		##
			c = <empty-code>;
			<err-syntax>(c);
		};

	] = {
		cx = expr;

		{
			sep;

			c = expr-list;

			<code-wind>(&c, cx);
		||
			sep;
			c = cx;
		||
			c = cx;
		};
	};

	script [

		global-expr-list = {
			c = expr;
			sep;

			t1 = <type-set>;
			<code-anon>(&c, t1, c);

			s = <var-top>;
			<code-data>(&c, s);

			t2 = <type-null>;
			<code-push>(&c, t2);

			<dispatch>(&c);

			{
				global-expr-list;
			||
				$;
			};
		};

	] = {
		{
			global-expr-list;
		||
			$;
		};

		eof;
	};

%entry%

	script;

