%types%

	string;
	!frame;
	type;
	code;

%terminals%

	!error;
	!panic;

	eof;
	nl;
	semi;
	bg;
	equ;
	!dot;
	!back;
	pipe;
	obrace;
	cbrace;
	oparen;
	cparen;
	or;
	and;
	!exec;

	str: () -> (:string);
	var: () -> (:string);

%productions%

	<dispatch>: (:code &) -> ();
	<populate>;

	<var-anon>: () -> (:string);
	<var-self>: () -> (:string);
	<var-top>:  () -> (:string);

	<empty>: () -> (:code);

	<type-null>: () -> (:type);
	<type-not>:  () -> (:type);
	<type-call>: () -> (:type);
	<type-exec>: () -> (:type);
	<type-if>:   () -> (:type);
	!<type-join>:() -> (:type);
	<type-pipe>: () -> (:type);
	<type-set>:  () -> (:type);

	<push-data>: (:code &, :string) -> ();
	<push-code>: (:code &, :type)   -> ();

	<frame-push>;
	<frame-pop>;
	<frame-set>: (:string, :code) -> ();

	exprs:     (:code &) -> ();
	exec-list: (:code &) -> ();

	compound-expr: (c :code &) -> () = {
		oparen;
		exec-list(&c);
		cparen;
	||
		obrace;
		<frame-push>;
		(ci) = <empty>;
		exprs(&ci);
		s = <var-self>;
		<frame-set>(s, ci);
		<frame-pop>;
		cbrace;
	};

	value: (c :code &) -> () = {
		compound-expr(&c);
	||
		s = str;
		<push-data>(&c, s);
	||
		s = var;
		<push-data>(&c, s);
		t = <type-call>;
		<push-code>(&c, t);
	};

	exec-list: (c :code &) -> () = {
		/* TODO: || backtick */
		{
			s = str;
			<push-data>(&c, s);
		||
			s = var;
			<push-data>(&c, s);
			t = <type-call>;
			<push-code>(&c, t);
		||
			compound-expr(&c);
		};

		{
			exec-list(&c);
		||
			t = <type-null>;
			<push-code>(&c, t);
		};
	};

	arg-list: (c :code &) -> () = {
		/* TODO: || backtick */
		{
			s = str;
			<push-data>(&c, s);
		||
			s = var;
			<push-data>(&c, s);
			t = <type-call>;
			<push-code>(&c, t);
		};

		{
			arg-list(&c);
		||
			t = <type-null>;
			<push-code>(&c, t);
		};
	};

	assign-expr: (c :code &) -> () = {
		arg-list(&c);
		t = <type-exec>;
		<push-code>(&c, t);
	||
		s = str;
		equ;
		value(&c);
		<push-data>(&c, s);
		t = <type-set>;
		<push-code>(&c, t);
	};

	pipe-expr: (c :code &) -> () = {
		assign-expr(&c);

		{
			pipe;
			pipe-expr(&c);
			t = <type-pipe>;
			<push-code>(&c, t);
		||
			$;
		};
	};

	and-expr: (c :code &) -> () = {
		pipe-expr(&c);

		{
			<frame-push>;
			and;
			(ci) = <empty>;
			and-expr(&ci);
			s = <var-anon>;
			<frame-set>(s, ci);
			<frame-pop>;

			t = <type-if>;
			<push-code>(&c, t);
		||
			$;
		};
	};

	or-expr: (c :code &) -> () = {
		and-expr(&c);

		{
			<frame-push>;
			or;
			(ci) = <empty>;
			or-expr(&ci);
			s = <var-anon>;
			<frame-set>(s, ci);
			<frame-pop>;

			t1 = <type-call>;
			<push-code>(&c, t1);

			t2 = <type-not>;
			<push-code>(&c, t2);

			t3 = <type-if>;
			<push-code>(&c, t3);
		||
			$;
		};
	};

	exprs: (c :code &) -> () [

		::expr: (c :code &) -> () = {
			or-expr(&c);

			{
				nl;
			||
				semi;
			||
				bg;
				/* TODO: <code-bg>(c); and set $% as jobid */
			};
		||
			nl;
		||
			semi;
		};

	] = {
		expr(&c);

		{
			exprs(&c);
		||
			$;
		};
	};

	script [

		global-exprs = {
			(c) = <empty>;

			expr(&c);

			<dispatch>(&c);

			s = <var-top>;
			<frame-set>(s, c);

			{
				global-exprs;
			||
				$;
			};
		};

	] = {
		<frame-push>;
		<populate>;
		global-exprs;
		<frame-pop>;

		eof;
	};

%entry%

	script;

