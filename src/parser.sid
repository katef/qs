%types%

	string;
	!frame;
	type;
	code;
	data;

%terminals%

	!error;
	!panic;

	eof;
	nl;
	semi;
	bg;
	equ;
	!dot;
	!back;
	pipe;
	obrace;
	cbrace;
	oparen;
	cparen;
	or;
	and;
	!exec;

	str: () -> (:string);
	var: () -> (:string);

%productions%

	<dispatch>: (:code &, :data &) -> ();
	<populate>;

	<var-anon>: () -> (:string);
	<var-self>: () -> (:string);
	<var-top>:  () -> (:string);

	<empty>: () -> (:code, :data);

	!<type-null>:() -> (:type);
	<type-not>:  () -> (:type);
	<type-call>: () -> (:type);
	<type-exec>: () -> (:type);
	<type-if>:   () -> (:type);
	!<type-join>:() -> (:type);
	<type-pipe>: () -> (:type);
	<type-set>:  () -> (:type);

	<push-data>: (:data &, :string) -> ();
	<push-null>: (:data &)          -> ();
	<push-code>: (:code &, :type)   -> ();

	<frame-push>;
	<frame-pop>;
	<frame-set>: (:string, :code, :data) -> ();

	exprs:     (:code &, :data &) -> ();
	exec-list: (:code &, :data &) -> ();

	compound-expr: (c :code &, d :data &) -> () = {
		oparen;
		exec-list(&c, &d);
		cparen;
	||
		obrace;
		<frame-push>;
		(ci, di) = <empty>;
		exprs(&ci, &di);
		s = <var-self>;
		<frame-set>(s, ci, di);
		<frame-pop>;
		cbrace;
	};

	value: (c :code &, d :data &) -> () = {
		compound-expr(&c, &d);
	||
		s = str;
		<push-data>(&d, s);
	||
		s = var;
		<push-data>(&d, s);
		t = <type-call>;
		<push-code>(&c, t);
	};

	exec-list: (c :code &, d :data &) -> () = {
		/* TODO: || backtick */
		{
			s = str;
			<push-data>(&d, s);
		||
			s = var;
			<push-data>(&d, s);
			t = <type-call>;
			<push-code>(&c, t);
		||
			compound-expr(&c, &d);
		};

		{
			exec-list(&c, &d);
		||
			<push-null>(&d);
		};
	};

	arg-list: (c :code &, d :data &) -> () = {
		/* TODO: || backtick */
		{
			s = str;
			<push-data>(&d, s);
		||
			s = var;
			<push-data>(&d, s);
			t = <type-call>;
			<push-code>(&c, t);
		};

		{
			arg-list(&c, &d);
		||
			<push-null>(&d);
		};
	};

	assign-expr: (c :code &, d :data &) -> () = {
		arg-list(&c, &d);
		t = <type-exec>;
		<push-code>(&c, t);
	||
		s = str;
		equ;
		value(&c, &d);
		<push-data>(&d, s);
		t = <type-set>;
		<push-code>(&c, t);
	};

	pipe-expr: (c :code &, d :data &) -> () = {
		assign-expr(&c, &d);

		{
			pipe;
			pipe-expr(&c, &d);
			t = <type-pipe>;
			<push-code>(&c, t);
		||
			$;
		};
	};

	and-expr: (c :code &, d :data &) -> () = {
		pipe-expr(&c, &d);

		{
			<frame-push>;

			and;
			(ci, di) = <empty>;
			and-expr(&ci, &di);
			s = <var-anon>;
			<frame-set>(s, ci, di);

			t = <type-if>;
			<push-code>(&c, t);

			<frame-pop>;
		||
			$;
		};
	};

	or-expr: (c :code &, d :data &) -> () = {
		and-expr(&c, &d);

		{
			<frame-push>;

			or;
			(ci, di) = <empty>;
			or-expr(&ci, &di);
			s = <var-anon>;
			<frame-set>(s, ci, di);

			t1 = <type-call>;
			<push-code>(&c, t1);

			t2 = <type-not>;
			<push-code>(&c, t2);

			t3 = <type-if>;
			<push-code>(&c, t3);

			<frame-pop>;
		||
			$;
		};
	};

	exprs: (c :code &, d :data &) -> () [

		::expr: (c :code &, d :data &) -> () = {
			or-expr(&c, &d);

			{
				nl;
			||
				semi;
			||
				bg;
				/* TODO: <code-bg>(&c); and set $% as jobid */
			};
		||
			nl;
		||
			semi;
		};

	] = {
		expr(&c, &d);

		{
			exprs(&c, &d);
		||
			$;
		};
	};

	script [

		global-exprs = {
			(c, d) = <empty>;

			expr(&c, &d);

			<dispatch>(&c, &d);

			s = <var-top>;
			<frame-set>(s, c, d);

			{
				global-exprs;
			||
				$;
			};
		};

	] = {
		<frame-push>;
		<populate>;
		global-exprs;
		<frame-pop>;

		eof;
	};

%entry%

	script;

