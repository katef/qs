%types%

	string;
	!frame;
	type;
	code;

%terminals%

	!error;
	!panic;

	eof;
	nl;
	semi;
	!bg;
	equ;
	comma;
	!dot;
	tick;
	bar;
	obrace;  cbrace;
	oparen;  cparen;
	osquare; csquare;
	or;
	and;
	!exec;

	word: () -> (:string);
	var:  () -> (:string);

%productions%

	<dispatch>: (:code &) -> ();

	<var-top>:  () -> (:string);

	<empty-code>: () -> (:code);

	<stdin>:  () -> (:string);
	!<stdout>:() -> (:string);
	!<stderr>:() -> (:string);

	<type-call>: () -> (:type);
	!<type-join>:() -> (:type);
	<type-not>:  () -> (:type);
	<type-null>: () -> (:type);
	<type-ret>:  () -> (:type);
	<type-run>:  () -> (:type);

	!<type-data>:() -> (:type);
	<type-dup>:  () -> (:type);
	<type-if>:   () -> (:type);
	<type-pipe>: () -> (:type);
	<type-set>:  () -> (:type);
	<type-tick>: () -> (:type);

	<prepend-anon>: (:code &, :type, :code) -> ();
	<prepend-data>: (:code &, :string)      -> ();
	<prepend-code>: (:code &, :type)        -> ();
	<prepend-cat>:  (:code &, :code)        -> ();

	<append-anon>:  (:code &, :type, :code) -> ();
	<append-data>:  (:code &, :string)      -> ();
	<append-code>:  (:code &, :type)        -> ();
	<append-cat>:   (:code &, :code)        -> ();

	<frame-push>;
	<frame-pop>;
	<frame-set>: (:string, :code) -> ();

	<err-expected-sep>;
	<err-syntax>: (:code) -> ();

	block:     () -> (:code);
	expr-list: () -> (:code);

	list: () -> (c :code) [

		::item: () -> (c :code) = {
			s = word;

			c = <empty-code>;
			<prepend-data>(&c, s);
		||
			s = var;

			c = <empty-code>;
			t = <type-call>;
			<prepend-code>(&c, t);
			<prepend-data>(&c, s);
		||
			tick;

			{
				c = item;
			||
				c = block;
			};

			/* tick rhs */
			{
				ci = <empty-code>;

				t3 = <type-tick>;
				<prepend-code>(&ci, t3);

				t4 = <type-ret>;
				<append-code>(&ci, t4);
			};

			t0 = <type-null>;
			<prepend-code>(&c, t0);

			t5 = <type-run>;
			<append-code>(&c, t5);

			t2 = <type-pipe>;
			<prepend-anon>(&c, t2, ci);
		};

	] = {
		c = item;

		{
			ci = list;
			<prepend-cat>(&c, ci);
		||
			$;
		};
	};

	assign-expr: () -> (c :code) [

		value: () -> (c :code) = {
			oparen;
			c = list;
			cparen;
		||
			c = item;
		||
			c = block;
		};

	] = {
		s = word;
		equ;
		ci = value;

		/* TODO: maybe prepend this, after, and just have c = value */
		c = <empty-code>;
		<append-data>(&c, s);

		t0 = <type-ret>;
		<append-code>(&ci, t0);

		t1 = <type-set>;
		<append-anon>(&c, t1, ci);
	};

	block-expr: () -> (c :code) [

		::block: () -> (c :code) = {
			obrace;
			<frame-push>;
			{
				c = expr-list;
			||
				c = <empty-code>;
			};
			<frame-pop>;
			cbrace;
		};

	] = {
		c = list;

		t0 = <type-null>;
		<prepend-code>(&c, t0);

		t1 = <type-run>;
		<append-code>(&c, t1);
	||
		c = block;
	};

	dup-expr: () -> (c :code) [

		/* here I would use zones if the lexer supported it, and emit tok_fd */
		/* TODO: permit [$x=$y] here */
		dup-item: (c :code &) -> () = {
			l = word;
			equ;
			r = word;

			<prepend-data>(&c, r);
			<prepend-data>(&c, l);
		||
			l = word;
			equ;

			<prepend-null>(&c);
			<prepend-data>(&c, l);
		||
			l = word;
			r = <stdin>;

			<prepend-data>(&c, r);
			<prepend-data>(&c, l);
		};

		dup-list: (c :code &) -> () = {
			dup-item(&c);

			{
				comma;
				dup-list(&c);
			||
				$;
			};
		};

	] = {
		c = block-expr;

		{
			osquare;
			dup-list(&c);
			csquare;

			t0 = <type-dup>;
			<prepend-code>(&c, t0);
		||
			$;
		};
	};

	pipe-expr: () -> (c :code) = {
		c = dup-expr;

		{
			bar;

			ci = pipe-expr;

			t0 = <type-ret>;
			<append-code>(&ci, t0);

			t2 = <type-pipe>;
			<prepend-anon>(&c, t2, ci);
		||
			$;
		};
	};

	and-expr: () -> (c :code) = {
		{
			c = pipe-expr;
		||
			c = assign-expr;
		};

		{
			and;

			ci = and-expr;

			t0 = <type-ret>;
			<append-code>(&ci, t0);

			t2 = <type-if>;
			<append-anon>(&c, t2, ci);
		||
			$;
		};
	};

	or-expr: () -> (c :code) = {
		c = and-expr;

		{
			or;

			ci = or-expr;

			t0 = <type-ret>;
			<append-code>(&ci, t0);

			t1 = <type-not>;
			<append-code>(&c, t1);

			t2 = <type-if>;
			<append-anon>(&c, t2, ci);
		||
			$;
		};
	};

	expr-list: () -> (c :code) [

		::sep = {
			nl;
		||
			semi;
		##
			<err-expected-sep>;
		};

		::expr: () -> (c :code) = {
			c = or-expr;
		##
			c = <empty-code>;
			<err-syntax>(c);
		};

	] = {
		c = expr;

		{
			sep;

			ci = expr-list;

			<append-cat>(&c, ci);
		||
			sep;
		||
			$;
		};
	};

	script [

		global-expr-list = {
			c = expr;
			sep;

			<dispatch>(&c);

			s = <var-top>;
			<frame-set>(s, c);

			{
				global-expr-list;
			||
				$;
			};
		};

	] = {
		<frame-push>;
		{
			global-expr-list;
		||
			$;
		};
		<frame-pop>;

		eof;
	};

%entry%

	script;

