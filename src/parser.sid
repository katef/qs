%types%

	string;
	!frame;
	type;
	code;
	pipe;
	fd;

%terminals%

	!error;
	!panic;

	eof;
	nl;
	semi;
	bg;
	equ;
	comma;
	!dot;
	tick;
	bar;
	obrace;  cbrace;
	oparen;  cparen;
	osquare; csquare;
	or;
	and;
	!exec;

	str: () -> (:string);
	var: () -> (:string);

%productions%

	<dispatch>: (:code &) -> ();

	<var-top>:  () -> (:string);

	<empty-code>: () -> (:code);
	<empty-pipe>: () -> (:pipe);

	<stdin>:   () -> (:fd);
	!<stdout>: () -> (:fd);
	!<stderr>: () -> (:fd);

	<type-null>: () -> (:type);
	<type-anon>: () -> (:type);
	<type-ret>:  () -> (:type);
	<type-not>:  () -> (:type);
	<type-tick>: () -> (:type);
	<type-call>: () -> (:type);
	<type-exec>: () -> (:type);
	<type-if>:   () -> (:type);
	!<type-join>:() -> (:type);
	<type-pipe>: () -> (:type);
	<type-set>:  () -> (:type);

	<make-fd>:   (:string) -> (:fd);
	<make-pipe>: (:pipe &, :fd, :fd) -> ();

	<push-anon>: (:code &, :type, :code) -> ();
	<push-data>: (:code &, :string)      -> ();
	<push-code>: (:code &, :type)        -> ();
	<push-stack>:(:code &, :code)        -> ();

	<frame-push>;
	<frame-pop>;
	<frame-set>: (:string, :code) -> ();

	<err-expected-sep>;
	<err-syntax>: (:code) -> ();

	arg:        (:code &) -> ();
	exprs:      (:code &) -> ();
	tick-value: (:code &) -> ();

	arg-list: (c :code &) -> () [

		::arg: (c :code &) -> () = {
			s = str;
			<push-data>(&c, s);
		||
			s = var;
			t = <type-call>;
			<push-code>(&c, t);
			<push-data>(&c, s);
		};

	] = {
		{
			arg(&c);
		||
			tick-value(&c);
		};

		{
			arg-list(&c);
		||
			t = <type-null>;
			<push-code>(&c, t);
		};
	};

	assign-expr: (c :code &) -> () [

		block: (c :code &) -> () = {
			obrace;
			<frame-push>;
			{
				exprs(&c);
			||
				$;
			};
			<frame-pop>;
			cbrace;
		};

		value: (c :code &) -> () = {
			oparen;
			arg-list(&c);
			cparen;
		||
			block(&c);
		||
			arg(&c);
		};

		::tick-value: (c :code &) -> () = {
			tick;

			t1 = <type-tick>;
			<push-code>(&c, t1);

			{
				arg(&c);

				t2 = <type-null>;
				<push-code>(&c, t2);
			||
				ci = <empty-code>;

				block(&ci);

				t0 = <type-ret>;
				<push-code>(&ci, t0);

				t3 = <type-anon>;
				<push-anon>(&c, t4, ci);

				t3 = <type-null>;
				<push-code>(&c, t3);

				/* XXX: would need to set up pipe for ` here, first. inner #exec are not dup2'd */
				/* XXX: maybe best to have #exec take a u.pipe argument for dup2 */
			};
		};

	] = {
		ci = <empty-code>;

		/*
		 * SID's parsing has single-token lookahead. This has the effect that
		 * actions must come before disambiguating the next token. Because LL(1)
		 * parsing does not permit leftmost recursion, the <stack-push> actions
		 * must be called after recurring - i.e. in reverse order.
		 * So <push-stack> is expected to wind instructions in reverse order,
		 * to counter that &ci is constructed backwards.
		 */

		{
			arg-list(&ci);

			<push-stack>(&c, ci);

			t = <type-exec>;
			<push-code>(&c, t);
		||
			block(&c);
		||
			s = str;
			equ;
			{
				value(&ci);
			||
				tick-value(&ci);
			};

			<push-data>(&c, s);

			t1 = <type-set>;
			<push-code>(&c, t1);

			t0 = <type-ret>;
			<push-code>(&ci, t0);

			t2 = <type-anon>;
			<push-anon>(&c, t2, ci);
		};
	};

	pipe-expr: (c :code &, p :pipe &) -> () [

		/* here I would use zones if the lexer supported it, and emit tok_fd */
		redir: (p :pipe &) -> () = {
			{
				n = str;
				equ;
				m = str;

				l = <make-fd>(n);
				r = <make-fd>(m);
			||
				n = str;

				l = <make-fd>(n);
				r = <stdin>;
			};

			<make-pipe>(&p, l, r);
		};

		redir-list: (p :pipe &) -> () = {
			redir(&p);

			{
				comma;
				redir-list(&p);
			||
				$;
			};
		};

	] = {
		assign-expr(&c);

		{
			pi = <empty-pipe>;

			bar;
			{
				osquare;
				redir-list(&pi);
				csquare;
			||
				$;
			};

			pipe-expr(&c, &pi);

			t = <type-pipe>;
			<push-code>(&c, t);
		||
			$;
		};
	};

	and-expr: (c :code &) -> () = {
		p = <empty-pipe>;

		pipe-expr(&c, &p);

		{
			and;

			ci = <empty-code>;
			and-expr(&ci);

			t0 = <type-ret>;
			<push-code>(&ci, t0);

			t1 = <type-if>;
			<push-anon>(&c, t1, ci);
		||
			$;
		};
	};

	or-expr: (c :code &) -> () = {
		and-expr(&c);

		{
			or;

			ci = <empty-code>;
			or-expr(&ci);

			t0 = <type-ret>;
			<push-code>(&ci, t0);

			t1 = <type-not>;
			<push-code>(&c, t1);

			t2 = <type-if>;
			<push-anon>(&c, t2, ci);
		||
			$;
		};
	};

	exprs: (c :code &) -> () [

		::sep = {
			nl;
		||
			semi;
		||
			bg;
			/* TODO: <code-bg>(c); and set $% as jobid */
		##
			<err-expected-sep>;
		};

		::expr: (c :code &) -> () = {
			or-expr(&c);
		##
			<err-syntax>(c);
		};

	] = {
		expr(&c);

		{
			sep;
			exprs(&c);
		||
			sep;
		||
			$;
		};
	};

	script [

		global-exprs = {
			c = <empty-code>;

			expr(&c);
			sep;

			<dispatch>(&c);

			s = <var-top>;
			<frame-set>(s, c);

			{
				global-exprs;
			||
				$;
			};
		};

	] = {
		<frame-push>;
		{
			global-exprs;
		||
			$;
		};
		<frame-pop>;

		eof;
	};

%entry%

	script;

